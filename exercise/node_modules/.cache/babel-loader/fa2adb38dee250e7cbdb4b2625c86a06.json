{"ast":null,"code":"/*╔═════════════════════════════════════════════════════════════════════════════════════════════════════════╗\n *║                                                                                                         ║\n *║      vptree.js v0.1.1                                                                                   ║\n *║      https://github.com/fpirsch/vptree.js                                                               ║\n *║                                                                                                         ║\n *║      A javascript implementation of the Vantage-Point Tree algorithm                                    ║\n *║      ISC license (http://opensource.org/licenses/ISC). François Pirsch. 2013.                           ║\n *║                                                                                                         ║\n *║      Date: 2013-09-21T20:03Z                                                                            ║\n *║                                                                                                         ║\n *╚═════════════════════════════════════════════════════════════════════════════════════════════════════════╝\n */\n\"use strict\"; //https://github.com/umdjs/umd/blob/master/commonjsStrictGlobal.js\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['exports'], function (exports) {\n      factory(root.VPTreeFactory = exports);\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    factory(exports);\n  } else {\n    // Browser globals\n    factory(root.VPTreeFactory = {});\n  }\n})(this, function (exports) {\n  /*───────────────────────────────────────────────────────────────────────────┐\n   │   Selection/partition algorithm                                           │\n   └───────────────────────────────────────────────────────────────────────────*/\n  function partition(list, left, right, pivotIndex, comp) {\n    var pivotValue = list[pivotIndex];\n    var swap = list[pivotIndex]; // Move pivot to end\n\n    list[pivotIndex] = list[right];\n    list[right] = swap;\n    var storeIndex = left;\n\n    for (var i = left; i < right; i++) {\n      if (comp(list[i], pivotValue)) {\n        swap = list[storeIndex];\n        list[storeIndex] = list[i];\n        list[i] = swap;\n        storeIndex++;\n      }\n    }\n\n    swap = list[right]; // Move pivot to its final place\n\n    list[right] = list[storeIndex];\n    list[storeIndex] = swap;\n    return storeIndex;\n  } // Pivot selection : computes the median of elements a, b and c of the list,\n  // according to comparator comp.\n\n\n  function medianOf3(list, a, b, c, comp) {\n    var A = list[a],\n        B = list[b],\n        C = list[c];\n    return comp(A, B) ? comp(B, C) ? b : comp(A, C) ? c : a : comp(A, C) ? a : comp(B, C) ? c : b;\n  }\n  /**\n   * Quickselect : Finds the nth smallest number in a list according to comparator comp.\n   * All elements smaller than the nth element are moved to its left (in no particular order),\n   * and all elements greater thant the nth are moved to its right.\n   *\n   * The funny mix of 0-based and 1-based indexes comes from the C++\n   * Standard Library function nth_element.\n   *\n   * @param {Array} list the list to partition\n   * @param {int} left index in the list of the first element of the sublist.\n   * @param {int} right index in the list of the last element of the sublist (inclusive)\n   * @param {int} nth index, in the range [1, sublist.length] of the elemnt to find.\n   * @param {function} comp a comparator, i.e. a boolean function accepting two parameters a and b,\n   *        and returning true if a < b and false if a >= b.\n   *\n   * See http://en.wikipedia.org/wiki/Quickselect\n   * And /include/bits/stl_algo.h in the GCC Standard Library ( http://gcc.gnu.org/libstdc++/ )\n   */\n\n\n  function nth_element(list, left, nth, right, comp) {\n    if (nth <= 0 || nth > right - left + 1) throw \"VPTree.nth_element: nth must be in range [1, right-left+1] (nth=\" + nth + \")\";\n    var pivotIndex, pivotNewIndex, pivotDist;\n\n    for (;;) {\n      // select pivotIndex between left and right\n      pivotIndex = medianOf3(list, left, right, left + right >> 1, comp);\n      pivotNewIndex = partition(list, left, right, pivotIndex, comp);\n      pivotDist = pivotNewIndex - left + 1;\n\n      if (pivotDist === nth) {\n        return list[pivotNewIndex];\n      } else if (nth < pivotDist) {\n        right = pivotNewIndex - 1;\n      } else {\n        nth -= pivotDist;\n        left = pivotNewIndex + 1;\n      }\n    }\n  }\n  /**\n   * Wrapper around nth_element with a 0-based index.\n   */\n\n\n  function select(list, k, comp) {\n    if (k < 0 || k >= list.length) throw \"VPTree.select: k must be in range [0, list.length-1] (k=\" + k + \")\";\n    return nth_element(list, 0, k + 1, list.length - 1, comp);\n  }\n  /*───────────────────────────────────────────────────────────────────────────┐\n   │   vp-tree creation                                                        │\n   └───────────────────────────────────────────────────────────────────────────*/\n\n  /** Selects a vantage point in a set.\n   *  We trivially pick one at random.\n   *  TODO this could be improved by random sampling to maximize spread.\n   */\n\n\n  function selectVPIndex(list) {\n    return Math.floor(Math.random() * list.length);\n  }\n\n  var distanceComparator = function distanceComparator(a, b) {\n    return a.dist < b.dist;\n  };\n  /**\n   * Builds and returns a vp-tree from the list S.\n   * @param {Array} S array of objects to structure into a vp-tree.\n   * @param {function} distance a function returning the distance between 2 ojects from the list S.\n   * @param {number} nb (maximum) bucket size. 0 or undefined = no buckets used.\n   * @return {object} vp-tree.\n   */\n\n\n  function buildVPTree(S, distance, nb) {\n    var list = [];\n\n    for (var i = 0, n = S.length; i < n; i++) {\n      list[i] = {\n        i: i //hist: []\t\t// unused (yet)\n\n      };\n    }\n\n    ;\n    var tree = recurseVPTree(S, list, distance, nb);\n    return new VPTree(S, distance, tree);\n  }\n\n  function recurseVPTree(S, list, distance, nb) {\n    if (list.length === 0) return null; // Is this a leaf node ?\n\n    var listLength = list.length;\n\n    if (nb > 0 && listLength <= nb) {\n      var bucket = [];\n\n      for (var i = 0; i < listLength; i++) {\n        bucket[i] = list[i].i;\n      }\n\n      return bucket;\n    } // Non-leaf node.\n    // Constructs a node with the selected vantage point extracted from the set.\n\n\n    var vpIndex = selectVPIndex(list),\n        node = list[vpIndex];\n    list.splice(vpIndex, 1);\n    listLength--; // We can't use this information yet, so don't show it in the vp-tree output.\n\n    delete node.dist;\n    if (listLength === 0) return node; // Adds to each item its distance to the vantage point.\n    // This ensures each distance is computed only once.\n\n    var vp = S[node.i],\n        dmin = Infinity,\n        dmax = 0,\n        item,\n        dist;\n\n    for (var i = 0, n = listLength; i < n; i++) {\n      item = list[i];\n      dist = distance(vp, S[item.i]);\n      item.dist = dist; //item.hist.push(dist);\t// unused (yet)\n\n      if (dmin > dist) dmin = dist;\n      if (dmax < dist) dmax = dist;\n    }\n\n    node.m = dmin;\n    node.M = dmax; // Partitions the set around the median distance.\n\n    var medianIndex = listLength >> 1,\n        median = select(list, medianIndex, distanceComparator); // Recursively builds vp-trees with the 2 resulting subsets.\n\n    var leftItems = list.splice(0, medianIndex),\n        rightItems = list;\n    node.μ = median.dist;\n    node.L = recurseVPTree(S, leftItems, distance, nb);\n    node.R = recurseVPTree(S, rightItems, distance, nb);\n    return node;\n  }\n  /** Stringifies a vp-tree data structure.\n   *  JSON without the null nodes and the quotes around object keys, to save space.\n   */\n\n\n  function stringify(root) {\n    var stack = [root || this.tree],\n        s = '';\n\n    while (stack.length) {\n      var node = stack.pop(); // Happens if the bucket size is greater thant the dataset.\n\n      if (node.length) return '[' + node.join(',') + ']';\n      s += '{i:' + node.i;\n\n      if (node.hasOwnProperty('m')) {\n        s += ',m:' + node.m + ',M:' + node.M + ',μ:' + node.μ;\n      }\n\n      if (node.hasOwnProperty('b')) {\n        s += ',b:[' + node.b + ']';\n      }\n\n      if (node.hasOwnProperty('L')) {\n        var L = node.L;\n\n        if (L) {\n          s += ',L:';\n          if (L.length) s += '[' + L + ']';else s += stringify(L);\n        }\n      }\n\n      if (node.hasOwnProperty('R')) {\n        var R = node.R;\n\n        if (R) {\n          s += ',R:';\n          if (R.length) s += '[' + R + ']';else s += stringify(R);\n        }\n      }\n\n      s += '}';\n    }\n\n    return s;\n  }\n  /*───────────────────────────────────────────────────────────────────────────┐\n   │   Build Public API                                                        │\n   └───────────────────────────────────────────────────────────────────────────*/\n\n\n  exports.select = select;\n  exports.build = buildVPTree;\n  /*───────────────────────────────────────────────────────────────────────────┐\n   │   Priority Queue, used to store search results.                           │\n   └───────────────────────────────────────────────────────────────────────────*/\n\n  /**\n   * @constructor\n   * @class PriorityQueue manages a queue of elements with priorities.\n   *\n   * @param {number} size maximum size of the queue (default = 5). Only lowest priority items will be retained.\n   */\n\n  function PriorityQueue(size) {\n    size = size || 5;\n    var contents = [];\n\n    function binaryIndexOf(priority) {\n      var minIndex = 0,\n          maxIndex = contents.length - 1,\n          currentIndex,\n          currentElement;\n\n      while (minIndex <= maxIndex) {\n        currentIndex = minIndex + maxIndex >> 1;\n        currentElement = contents[currentIndex].priority;\n\n        if (currentElement < priority) {\n          minIndex = currentIndex + 1;\n        } else if (currentElement > priority) {\n          maxIndex = currentIndex - 1;\n        } else {\n          return currentIndex;\n        }\n      }\n\n      return -1 - minIndex;\n    }\n\n    var api = {\n      // This breaks IE8 compatibility. Who cares ?\n      get length() {\n        return contents.length;\n      },\n\n      insert: function insert(data, priority) {\n        var index = binaryIndexOf(priority);\n        if (index < 0) index = -1 - index;\n\n        if (index < size) {\n          contents.splice(index, 0, {\n            data: data,\n            priority: priority\n          });\n\n          if (contents.length > size) {\n            contents.length--;\n          }\n        }\n\n        return contents.length === size ? contents[contents.length - 1].priority : Infinity;\n      },\n      list: function list() {\n        return contents.map(function (item) {\n          return {\n            i: item.data,\n            d: item.priority\n          };\n        });\n      }\n    };\n    return api;\n  }\n\n  ;\n  /*───────────────────────────────────────────────────────────────────────────┐\n   │   vp-tree search                                                          │\n   └───────────────────────────────────────────────────────────────────────────*/\n\n  /**\n   * @param {Object} q query : any object the distance function can be applied to.\n   * @param {number} n number of nearest neighbors to find (default = 1)\n   *\n   * @return {Array<Object>} list of search results, ordered by increasing distance to the query object.\n   *\t\t\t\t\t\tEach result has a property i which is the index of the element in S, and d which\n   *\t\t\t\t\t\tis its distance to the query object.\n   */\n\n  function searchVPTree(q, n) {\n    n = n || 1;\n    var W = new PriorityQueue(n),\n        τ = Infinity,\n        S = this.S,\n        distance = this.distance,\n        comparisons = 0;\n\n    function doSearch(node) {\n      if (node === null) return; // Leaf node : test each element in this node's bucket.\n\n      if (node.length) {\n        for (var i = 0, n = node.length; i < n; i++) {\n          comparisons++;\n          var elementID = node[i],\n              element = S[elementID],\n              elementDist = distance(q, element);\n\n          if (elementDist < τ) {\n            τ = W.insert(elementID, elementDist);\n          }\n        }\n\n        return;\n      } // Non-leaf node\n\n\n      var id = node.i,\n          p = S[id],\n          dist = distance(q, p);\n      comparisons++; // This vantage-point is close enough to q.\n\n      if (dist < τ) {\n        τ = W.insert(id, dist);\n      } // The order of exploration is determined by comparison with μ.\n      // The sooner we find elements close to q, the smaller τ and the more nodes we skip.\n      // P. Yianilos uses the middle of left/right bounds instead of μ.\n\n\n      var μ = node.μ,\n          L = node.L,\n          R = node.R;\n      if (μ === undefined) return;\n\n      if (dist < μ) {\n        if (L && node.m - τ < dist) doSearch(L);\n        if (R && μ - τ < dist && dist < node.M + τ) doSearch(R);\n      } else {\n        if (R && dist < node.M + τ) doSearch(R);\n        if (L && node.m - τ < dist && dist < μ + τ) doSearch(L);\n      }\n    }\n\n    doSearch(this.tree);\n    this.comparisons = comparisons;\n    return W.list();\n  }\n  /*───────────────────────────────────────────────────────────────────────────┐\n   │   vp-tree constructor                                                     │\n   └───────────────────────────────────────────────────────────────────────────*/\n\n  /**\n   * @constructor\n   * @class VPTree manages a vp-tree.\n   *\n   * @param {Array} S the initial set of elements\n   * @param {Function} distance the distance function\n   * @param {Object} the vp-tree structure\n   */\n\n\n  function VPTree(S, distance, tree) {\n    this.S = S;\n    this.distance = distance;\n    this.tree = tree;\n    this.search = searchVPTree;\n    this.comparisons = 0;\n    this.stringify = stringify;\n  }\n\n  exports.load = function (S, distance, tree) {\n    return new VPTree(S, distance, tree);\n  };\n});","map":null,"metadata":{},"sourceType":"script"}